| package |
package := Package name: 'ActiveX Automation'.
package paxVersion: 2;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk ActiveX Automation Support.
Copyright (c) Object Arts Ltd, 2000-2003.

This package is the basis of Dolphin''s extensive Active-X Automation support (formally called OLE Automation). It includes classes to enable the use of Dolphin as both an Automation client (or controller) and server. In here you will find classes to support the familar Automation types such as VARIANTs, BSTRs and SAFEARRAYs. This package also includes extensive support for extracting information from type libraries, with this being further augmented by the ''ActiveX Automation Development'' package, which uses the type-library analyzer to generate wrapper classes for COM objects, etc.

'.

package basicPackageVersion: '6.1'.

package basicScriptAt: #postinstall put: 'VMLibrary default
	registryAt: #BSTR put: BSTR;
	registryAt: #VARIANT put: VARIANT;
	registryAt: #IDispatch put: IDispatch.

"Register all the existing ExternalStructures so that they can support IRecordInfo"
ExternalStructure registerSubclasses.'.
package basicScriptAt: #postuninstall put: 'ExternalStructure classPool at: ''RecordClasses'' put: nil.'.

package setClassNames: #(
	#{AbstractELEMDESC}
	#{ARRAYDESC}
	#{AXAPIInfoAnalyzer}
	#{AXAutomationConstants}
	#{AXAutomationErrors}
	#{AXDispatchImpAbstract}
	#{AXDualImp}
	#{AXForwardingDualImp}
	#{AXInterfaceTypeAnalyzer}
	#{AXMemberDesc}
	#{AXRecord}
	#{AXStructureTypeAnalyzer}
	#{AXTypeGenerationFlags}
	#{AXTypeInfoAnalyzer}
	#{AXTypeInfoObject}
	#{AXTypeInfoStructure}
	#{AXTypeLibDocumentation}
	#{AXTypeLibraryAnalyzer}
	#{COMVariantEnumerator}
	#{CURRENCY}
	#{CUSTDATA}
	#{CUSTDATAITEM}
	#{DATE}
	#{DECIMAL}
	#{DispFunction}
	#{DISPPARAMS}
	#{ELEMDESC}
	#{FONTDESC}
	#{FUNCDESC}
	#{ICreateErrorInfo}
	#{IDispatch}
	#{IDLDESC}
	#{IEnumVARIANT}
	#{IPerPropertyBrowsing}
	#{IProvideClassInfo}
	#{IProvideClassInfo2}
	#{IRecordInfo}
	#{ITypeComp}
	#{ITypeInfo}
	#{ITypeInfo2}
	#{ITypeLib}
	#{ITypeLib2}
	#{LPBSTR}
	#{PARAMDESC}
	#{PARAMDESCEX}
	#{SAFEARRAY}
	#{SAFEARRAYBOUND}
	#{TKindAliasAnalyzer}
	#{TKindCoclassAnalyzer}
	#{TKindDispatchAnalyzer}
	#{TKindEnumAnalyzer}
	#{TKindInterfaceAnalyzer}
	#{TKindModuleAnalyzer}
	#{TKindRecordAnalyzer}
	#{TKindUnionAnalyzer}
	#{TLIBATTR}
	#{TYPEATTR}
	#{TYPEDESC}
	#{VARDESC}
	#{VARIANT}
	#{VARIANT_BOOL}
).

package setMethodNames: #(
	#(#{BOOL class} #typeName)
	#(#{Boolean} #asVariant)
	#(#{BOOLEAN class} #typeName)
	#(#{BSTR} #asSAFEARRAY)
	#(#{BSTR} #asVariant)
	#(#{BSTR class} #fromObject:)
	#(#{BSTR class} #newSAFEARRAY:)
	#(#{BSTR class} #typeName)
	#(#{BSTR class} #vt)
	#(#{BYTE class} #typeName)
	#(#{BYTE class} #vt)
	#(#{ByteArray} #asSAFEARRAY)
	#(#{ByteArray class} #typeName)
	#(#{Character} #asVariant)
	#(#{CLSID class} #newSAFEARRAY:)
	#(#{CLSID class} #vt)
	#(#{Collection} #asSAFEARRAY)
	#(#{Collection} #asVariant)
	#(#{COMInterface} #coclassTypeInfo)
	#(#{COMInterface} #coclassTypeInfoIfNone:)
	#(#{COMInterface} #typeInfo)
	#(#{COMInterface} #typeInfoIfNone:)
	#(#{COMInterface class} #coclassTypeInfo)
	#(#{COMInterface class} #coclassTypeInfoIfNone:)
	#(#{COMInterface class} #errorNoTypeInfo)
	#(#{COMInterface class} #fromObject:)
	#(#{COMInterface class} #newSAFEARRAY:)
	#(#{COMInterface class} #registerDispinterface:)
	#(#{COMInterface class} #typeInfoIfNone:)
	#(#{COMInterface class} #typeLib)
	#(#{Date} #asFloat)
	#(#{Date} #asVariant)
	#(#{DateAndTime} #asFloat)
	#(#{DateAndTime} #asVariant)
	#(#{DOUBLE class} #typeName)
	#(#{DOUBLE class} #vt)
	#(#{DWORD class} #typeName)
	#(#{DWORD class} #vt)
	#(#{ExternalAddress class} #typeName)
	#(#{ExternalAddress class} #vt)
	#(#{ExternalArray} #asSAFEARRAY)
	#(#{ExternalArray} #asVariant)
	#(#{ExternalArray class} #vt)
	#(#{ExternalHandle class} #typeName)
	#(#{ExternalInteger class} #typeName)
	#(#{ExternalInteger class} #vt)
	#(#{ExternalScalar} #asVariant)
	#(#{ExternalStructure} #asVariant)
	#(#{ExternalStructure} #recordInfo)
	#(#{ExternalStructure} #vt)
	#(#{ExternalStructure class} #classForGUID:ifNone:)
	#(#{ExternalStructure class} #clearGuid)
	#(#{ExternalStructure class} #finalRelease)
	#(#{ExternalStructure class} #fromAddress:recordInfo:owner:)
	#(#{ExternalStructure class} #fromObject:)
	#(#{ExternalStructure class} #GetField:szFieldName:pvarField:)
	#(#{ExternalStructure class} #GetFieldNames:rgBstrNames:)
	#(#{ExternalStructure class} #GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:)
	#(#{ExternalStructure class} #GetGuid:)
	#(#{ExternalStructure class} #GetName:)
	#(#{ExternalStructure class} #GetSize:)
	#(#{ExternalStructure class} #GetTypeInfo:)
	#(#{ExternalStructure class} #initializeRegister)
	#(#{ExternalStructure class} #IsMatchingType:)
	#(#{ExternalStructure class} #newSAFEARRAY:)
	#(#{ExternalStructure class} #pointerFieldType)
	#(#{ExternalStructure class} #PutField:pvData:szFieldName:pvarField:)
	#(#{ExternalStructure class} #PutFieldNoCopy:pvData:szFieldName:pvarField:)
	#(#{ExternalStructure class} #queryInterface:)
	#(#{ExternalStructure class} #queryInterface:ifNone:)
	#(#{ExternalStructure class} #RecordClear:)
	#(#{ExternalStructure class} #RecordCopy:pvNew:)
	#(#{ExternalStructure class} #RecordCreate)
	#(#{ExternalStructure class} #RecordCreateCopy:ppvDest:)
	#(#{ExternalStructure class} #RecordDestroy:)
	#(#{ExternalStructure class} #recordInfo)
	#(#{ExternalStructure class} #RecordInit:)
	#(#{ExternalStructure class} #registerSubclasses)
	#(#{ExternalStructure class} #supportedInterfaces)
	#(#{ExternalStructure class} #typeInfo)
	#(#{ExternalStructure class} #typeInfoIfNone:)
	#(#{ExternalStructure class} #typeLib)
	#(#{ExternalStructure class} #typeName)
	#(#{ExternalStructure class} #vt)
	#(#{FILETIME class} #vt)
	#(#{Float} #asVariant)
	#(#{FLOAT class} #typeName)
	#(#{FLOAT class} #vt)
	#(#{Fraction} #asVariant)
	#(#{GUID class} #typeName)
	#(#{HRESULT class} #typeName)
	#(#{HRESULT class} #vt)
	#(#{IErrorInfo class} #fromEXCEPINFO:guid:)
	#(#{IErrorInfo class} #source:description:helpContext:helpFile:guid:)
	#(#{INT_PTR class} #typeName)
	#(#{INT_PTR class} #vt)
	#(#{Integer} #asVariant)
	#(#{IUnknown} #asVariant)
	#(#{IUnknown class} #vt)
	#(#{LARGE_INTEGER class} #typeName)
	#(#{LARGE_INTEGER class} #vt)
	#(#{LargeInteger} #asVariant)
	#(#{Locale} #variantBool:)
	#(#{LPVOID class} #typeName)
	#(#{LPVOID class} #vt)
	#(#{OLEAutLibrary} #clearCustData:)
	#(#{OLEAutLibrary} #createErrorInfo:)
	#(#{OLEAutLibrary} #getRecordInfoFromTypeInfo:ppRecInfo:)
	#(#{OLEAutLibrary} #lHashValOfNameSys:lcid:szName:)
	#(#{OLEAutLibrary} #loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:)
	#(#{OLEAutLibrary} #loadTypeLib:pptlib:)
	#(#{OLEAutLibrary} #loadTypeLibEx:regkind:pptlib:)
	#(#{OLEAutLibrary} #oleCreateFontIndirect:riid:ppvObj:)
	#(#{OLEAutLibrary} #queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:)
	#(#{OLEAutLibrary} #registerTypeLib:wszFullPath:wszHelpDir:)
	#(#{OLEAutLibrary} #registerTypeLibForUser:szFullPath:szHelpDir:)
	#(#{OLEAutLibrary} #safeArrayAccessData:ppvData:)
	#(#{OLEAutLibrary} #safeArrayCopy:ppsaout:)
	#(#{OLEAutLibrary} #safeArrayCreateEx:cDims:rgsabound:pvExtra:)
	#(#{OLEAutLibrary} #safeArrayCreateVectorEx:lLbound:cElements:pvExtra:)
	#(#{OLEAutLibrary} #safeArrayDestroy:)
	#(#{OLEAutLibrary} #safeArrayGetDim:)
	#(#{OLEAutLibrary} #safeArrayGetElement:rgIndices:pv:)
	#(#{OLEAutLibrary} #safeArrayGetIID:pguid:)
	#(#{OLEAutLibrary} #safeArrayGetLBound:nDim:plLbound:)
	#(#{OLEAutLibrary} #safeArrayGetRecordInfo:prinfo:)
	#(#{OLEAutLibrary} #safeArrayGetUBound:nDim:plUbound:)
	#(#{OLEAutLibrary} #safeArrayGetVartype:pvt:)
	#(#{OLEAutLibrary} #safeArrayPtrOfIndex:rgIndices:ppvData:)
	#(#{OLEAutLibrary} #safeArrayPutElement:rgIndices:pv:)
	#(#{OLEAutLibrary} #safeArrayRedim:psaboundNew:)
	#(#{OLEAutLibrary} #safeArraySetIID:pguid:)
	#(#{OLEAutLibrary} #safeArrayUnaccessData:)
	#(#{OLEAutLibrary} #safeArrayUnlock:)
	#(#{OLEAutLibrary} #setErrorInfo:perrinfo:)
	#(#{OLEAutLibrary} #systemTimeToVariantTime:pvtime:)
	#(#{OLEAutLibrary} #unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:)
	#(#{OLEAutLibrary} #varBstrFromBool:lcid:dwFlags:pbstrOut:)
	#(#{OLEAutLibrary} #varCmp:pvarRight:lcid:dwFlags:)
	#(#{OLEAutLibrary} #varDateFromStr:lcid:dwFlags:pdateOut:)
	#(#{OLEAutLibrary} #variantChangeType:pvarSrc:wFlags:vt:)
	#(#{OLEAutLibrary} #variantChangeTypeEx:pvarSrc:lcid:wFlags:vt:)
	#(#{OLEAutLibrary} #variantClear:)
	#(#{OLEAutLibrary} #variantCopy:pvargSrc:)
	#(#{OLEAutLibrary} #variantCopyInd:pvargSrc:)
	#(#{OLEAutLibrary} #variantInit:)
	#(#{OLEAutLibrary} #variantTimeToSystemTime:lpSystemTime:)
	#(#{QWORD class} #vt)
	#(#{SBYTE class} #typeName)
	#(#{SBYTE class} #vt)
	#(#{ScaledDecimal} #asVariant)
	#(#{SDWORD class} #typeName)
	#(#{SDWORD class} #vt)
	#(#{SmallInteger} #asVariant)
	#(#{SmalltalkLocale} #variantBool:)
	#(#{String} #asVariant)
	#(#{String class} #pointerType)
	#(#{String class} #typeName)
	#(#{String class} #vt)
	#(#{SWORD class} #typeName)
	#(#{SWORD class} #vt)
	#(#{SYSTEMTIME} #asFloat)
	#(#{SYSTEMTIME} #asVariant)
	#(#{SYSTEMTIME class} #fromDATE:)
	#(#{UINT_PTR class} #typeName)
	#(#{UINT_PTR class} #vt)
	#(#{ULARGE_INTEGER class} #typeName)
	#(#{UndefinedObject} #asVariant)
	#(#{UndefinedObject class} #typeName)
	#(#{UndefinedObject class} #vt)
	#(#{Utf16String class} #pointerType)
	#(#{Utf16String class} #typeName)
	#(#{Utf16String class} #vt)
	#(#{VOID class} #typeName)
	#(#{VOID class} #vt)
	#(#{WindowsLocale} #boolFormat)
	#(#{WindowsLocale} #getVariantBoolString:)
	#(#{WindowsLocale} #variantBool:)
	#(#{WORD class} #typeName)
	#(#{WORD class} #vt)
).

package setPrerequisites: #(
	'..\..\Base\Dolphin'
	'..\..\Base\Dolphin Conformant Array Fields'
	'..\..\Base\Dolphin Legacy Date & Time'
	'..\COM\OLE COM'
).

package!

"Class Definitions"!

SharedPool subclass: #AXAutomationConstants
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'ACTIVEOBJECT_STRONG' -> 16r0.
		'ACTIVEOBJECT_WEAK' -> 16r1.
		'CC_CDECL' -> 16r1.
		'CC_MACPASCAL' -> 16r3.
		'CC_MAX' -> 16r9.
		'CC_MPWCDECL' -> 16r7.
		'CC_MPWPASCAL' -> 16r8.
		'CC_MSCPASCAL' -> 16r2.
		'CC_PASCAL' -> 16r2.
		'CC_RESERVED' -> 16r5.
		'CC_STDCALL' -> 16r4.
		'CC_SYSCALL' -> 16r6.
		'DESCKIND_FUNCDESC' -> 16r1.
		'DESCKIND_IMPLICITAPPOBJ' -> 16r4.
		'DESCKIND_MAX' -> 16r5.
		'DESCKIND_NONE' -> 16r0.
		'DESCKIND_TYPECOMP' -> 16r3.
		'DESCKIND_VARDESC' -> 16r2.
		'DISPATCH_METHOD' -> 16r1.
		'DISPATCH_PROPERTYGET' -> 16r2.
		'DISPATCH_PROPERTYPUT' -> 16r4.
		'DISPATCH_PROPERTYPUTREF' -> 16r8.
		'DISPID_COLLECT' -> -16r8.
		'DISPID_CONSTRUCTOR' -> -16r6.
		'DISPID_DESTRUCTOR' -> -16r7.
		'DISPID_EVALUATE' -> -16r5.
		'DISPID_NEWENUM' -> -16r4.
		'DISPID_PROPERTYPUT' -> -16r3.
		'DISPID_UNKNOWN' -> -16r1.
		'DISPID_VALUE' -> 16r0.
		'FADF_AUTO' -> 16r1.
		'FADF_BSTR' -> 16r100.
		'FADF_DISPATCH' -> 16r400.
		'FADF_EMBEDDED' -> 16r4.
		'FADF_FIXEDSIZE' -> 16r10.
		'FADF_HAVEIID' -> 16r40.
		'FADF_HAVEVARTYPE' -> 16r80.
		'FADF_RECORD' -> 16r20.
		'FADF_RESERVED' -> 16rF0E8.
		'FADF_STATIC' -> 16r2.
		'FADF_UNKNOWN' -> 16r200.
		'FADF_VARIANT' -> 16r800.
		'FUNC_DISPATCH' -> 16r4.
		'FUNC_NONVIRTUAL' -> 16r2.
		'FUNC_PUREVIRTUAL' -> 16r1.
		'FUNC_STATIC' -> 16r3.
		'FUNC_VIRTUAL' -> 16r0.
		'FUNCFLAG_FBINDABLE' -> 16r4.
		'FUNCFLAG_FDEFAULTBIND' -> 16r20.
		'FUNCFLAG_FDEFAULTCOLLELEM' -> 16r100.
		'FUNCFLAG_FDISPLAYBIND' -> 16r10.
		'FUNCFLAG_FHIDDEN' -> 16r40.
		'FUNCFLAG_FIMMEDIATEBIND' -> 16r1000.
		'FUNCFLAG_FNONBROWSABLE' -> 16r400.
		'FUNCFLAG_FREPLACEABLE' -> 16r800.
		'FUNCFLAG_FREQUESTEDIT' -> 16r8.
		'FUNCFLAG_FRESTRICTED' -> 16r1.
		'FUNCFLAG_FSOURCE' -> 16r2.
		'FUNCFLAG_FUIDEFAULT' -> 16r200.
		'FUNCFLAG_FUSESGETLASTERROR' -> 16r80.
		'ID_DEFAULTINST' -> -16r2.
		'IDLFLAG_FIN' -> 16r1.
		'IDLFLAG_FLCID' -> 16r4.
		'IDLFLAG_FOUT' -> 16r2.
		'IDLFLAG_FRETVAL' -> 16r8.
		'IDLFLAG_NONE' -> 16r0.
		'IMPLTYPEFLAG_FDEFAULT' -> 16r1.
		'IMPLTYPEFLAG_FRESTRICTED' -> 16r4.
		'IMPLTYPEFLAG_FSOURCE' -> 16r2.
		'INVOKE_FUNC' -> 16r1.
		'INVOKE_PROPERTYGET' -> 16r2.
		'INVOKE_PROPERTYPUT' -> 16r4.
		'INVOKE_PROPERTYPUTREF' -> 16r8.
		'LIBFLAG_FCONTROL' -> 16r2.
		'LIBFLAG_FHASDISKIMAGE' -> 16r8.
		'LIBFLAG_FHIDDEN' -> 16r4.
		'LIBFLAG_FRESTRICTED' -> 16r4.
		'MEMBERID_NIL' -> -16r1.
		'PARAMFLAG_FHASDEFAULT' -> 16r20.
		'PARAMFLAG_FIN' -> 16r1.
		'PARAMFLAG_FOPT' -> 16r10.
		'PARAMFLAG_FOUT' -> 16r2.
		'PARAMFLAG_FRETVAL' -> 16r8.
		'PARAMFLAG_NONE' -> 16r0.
		'REGKIND_DEFAULT' -> 16r0.
		'REGKIND_NONE' -> 16r2.
		'REGKIND_REGISTER' -> 16r1.
		'STDOLE_LCID' -> 16r0.
		'STDOLE_MAJORVERNUM' -> 16r1.
		'STDOLE_MINORVERNUM' -> 16r0.
		'SYS_MAC' -> 16r2.
		'SYS_WIN16' -> 16r0.
		'SYS_WIN32' -> 16r1.
		'TKIND_ALIAS' -> 16r6.
		'TKIND_COCLASS' -> 16r5.
		'TKIND_DISPATCH' -> 16r4.
		'TKIND_ENUM' -> 16r0.
		'TKIND_INTERFACE' -> 16r3.
		'TKIND_MAX' -> 16r8.
		'TKIND_MODULE' -> 16r2.
		'TKIND_RECORD' -> 16r1.
		'TKIND_UNION' -> 16r7.
		'TYPEFLAG_FAGGREGATABLE' -> 16r400.
		'TYPEFLAG_FAPPOBJECT' -> 16r1.
		'TYPEFLAG_FCANCREATE' -> 16r2.
		'TYPEFLAG_FCONTROL' -> 16r20.
		'TYPEFLAG_FDISPATCHABLE' -> 16r1000.
		'TYPEFLAG_FDUAL' -> 16r40.
		'TYPEFLAG_FHIDDEN' -> 16r10.
		'TYPEFLAG_FLICENSED' -> 16r4.
		'TYPEFLAG_FNONEXTENSIBLE' -> 16r80.
		'TYPEFLAG_FOLEAUTOMATION' -> 16r100.
		'TYPEFLAG_FPREDECLID' -> 16r8.
		'TYPEFLAG_FRESTRICTED' -> 16r200.
		'VAR_CONST' -> 16r2.
		'VAR_DATEVALUEONLY' -> 16r2.
		'VAR_DISPATCH' -> 16r3.
		'VAR_PERINSTANCE' -> 16r0.
		'VAR_STATIC' -> 16r1.
		'VAR_TIMEVALUEONLY' -> 16r1.
		'VARFLAG_FBINDABLE' -> 16r4.
		'VARFLAG_FDEFAULTBIND' -> 16r20.
		'VARFLAG_FDISPLAYBIND' -> 16r10.
		'VARFLAG_FHIDDEN' -> 16r40.
		'VARFLAG_FNONBROWSABLE' -> 16r400.
		'VARFLAG_FREADONLY' -> 16r1.
		'VARFLAG_FREQUESTEDIT' -> 16r8.
		'VARFLAG_FRESTRICTED' -> 16r80.
		'VARFLAG_FSOURCE' -> 16r2.
		'VARFLAG_FUIDEFAULT' -> 16r200.
		'VARIANT_ALPHABOOL' -> 16r2.
		'VARIANT_CALENDAR_GREGORIAN' -> 16r40.
		'VARIANT_CALENDAR_HIJRI' -> 16r8.
		'VARIANT_CALENDAR_THAI' -> 16r20.
		'VARIANT_FALSE' -> 16r0.
		'VARIANT_LOCALBOOL' -> 16r10.
		'VARIANT_NOUSEROVERRIDE' -> 16r4.
		'VARIANT_NOVALUEPROP' -> 16r1.
		'VARIANT_TRUE' -> -16r1.
		'VARIANT_USE_NLS' -> 16r80.
		'VT_ARRAY' -> 16r2000.
		'VT_BLOB' -> 16r41.
		'VT_BLOB_OBJECT' -> 16r46.
		'VT_BOOL' -> 16rB.
		'VT_BSTR' -> 16r8.
		'VT_BYREF' -> 16r4000.
		'VT_CARRAY' -> 16r1C.
		'VT_CF' -> 16r47.
		'VT_CLSID' -> 16r48.
		'VT_CY' -> 16r6.
		'VT_DATE' -> 16r7.
		'VT_DECIMAL' -> 16rE.
		'VT_DISPATCH' -> 16r9.
		'VT_EMPTY' -> 16r0.
		'VT_ERROR' -> 16rA.
		'VT_FILETIME' -> 16r40.
		'VT_HRESULT' -> 16r19.
		'VT_I1' -> 16r10.
		'VT_I2' -> 16r2.
		'VT_I4' -> 16r3.
		'VT_I8' -> 16r14.
		'VT_INT' -> 16r16.
		'VT_LPSTR' -> 16r1E.
		'VT_LPWSTR' -> 16r1F.
		'VT_NULL' -> 16r1.
		'VT_PTR' -> 16r1A.
		'VT_R4' -> 16r4.
		'VT_R8' -> 16r5.
		'VT_RECORD' -> 16r24.
		'VT_SAFEARRAY' -> 16r1B.
		'VT_STORAGE' -> 16r43.
		'VT_STORED_OBJECT' -> 16r45.
		'VT_STREAM' -> 16r42.
		'VT_STREAMED_OBJECT' -> 16r44.
		'VT_TYPEMASK' -> 16rFFF.
		'VT_UI1' -> 16r11.
		'VT_UI2' -> 16r12.
		'VT_UI4' -> 16r13.
		'VT_UI8' -> 16r15.
		'VT_UINT' -> 16r17.
		'VT_UNKNOWN' -> 16rD.
		'VT_USERDEFINED' -> 16r1D.
		'VT_VARIANT' -> 16rC.
		'VT_VECTOR' -> 16r1000.
		'VT_VOID' -> 16r18
	}!
SharedPool subclass: #AXAutomationErrors
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'DISP_E_ARRAYISLOCKED' -> -16r7FFDFFF3.
		'DISP_E_BADINDEX' -> -16r7FFDFFF5.
		'DISP_E_BADVARTYPE' -> -16r7FFDFFF8.
		'DISP_E_DIVBYZERO' -> -16r7FFDFFEE.
		'DISP_E_EXCEPTION' -> -16r7FFDFFF7.
		'DISP_E_MEMBERNOTFOUND' -> -16r7FFDFFFD.
		'DISP_E_OVERFLOW' -> -16r7FFDFFF6.
		'DISP_E_PARAMNOTFOUND' -> -16r7FFDFFFC.
		'DISP_E_TYPEMISMATCH' -> -16r7FFDFFFB.
		'DISP_E_UNKNOWNNAME' -> -16r7FFDFFFA.
		'TYPE_E_CANTLOADLIBRARY' -> -16r7FFD63B6.
		'TYPE_E_ELEMENTNOTFOUND' -> -16r7FFD7FD5.
		'TYPE_E_FIELDNOTFOUND' -> -16r7FFD7FE9.
		'TYPE_E_LIBNOTREGISTERED' -> -16r7FFD7FE3.
		'WCODE_HRESULT_FIRST' -> -16r7FFBFE00.
		'WCODE_HRESULT_LAST' -> -16r7FFB0001
	}!
SharedPool subclass: #AXTypeGenerationFlags
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'CommentStyleMask' -> 16r101.
		'DefineProtocol' -> 16r20.
		'LowercaseIdentifiers' -> 16r400.
		'MinimizeWrappers' -> 16r80.
		'NoClassComment' -> 16r1.
		'NoCompile' -> 16r40.
		'NoFunctionTable' -> 16r4.
		'NoSourceInterfaces' -> 16r200.
		'NoTypeLib' -> 16r2.
		'OverwriteClassComments' -> 16r100.
		'RawMethodsOnly' -> 16r10.
		'Trace' -> 16r8.
		'TraceOnly' -> 16r48.
		'Verbose' -> 16r800.
		'WrapperStyleMask' -> 16r90
	}!
Object subclass: #AXTypeInfoObject
	instanceVariableNames: 'tlbInterface generationFlags'
	classVariableNames: 'ClassCommentStyleMap GuidClash HighLevelWrapperStyleMap SuperclassClash TracingStyleMap'
	imports: #(#{AXAutomationConstants} #{AXTypeGenerationFlags})
	classInstanceVariableNames: ''
	classConstants: {}!
Object subclass: #AXTypeLibDocumentation
	instanceVariableNames: 'name helpstring helpcontext helpfile'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXTypeInfoObject subclass: #AXTypeInfoAnalyzer
	instanceVariableNames: 'typeLib globalBinding guid index documentation'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'VTtoIDLTypeMap' -> #(nil 'short' 'long' 'float' 'double' 'CURRENCY' 'DATE' 'BSTR' 'IDispatch*' 'SCODE' 'VARIANT_BOOL' 'VARIANT' 'IUnknown*' 'DECIMAL' nil 'char' 'BYTE' 'unsigned short' 'unsigned long' '__int64' 'unsigned __int64' 'int' 'unsigned int' 'void' 'HRESULT' '*' 'SAFEARRAY*' '[]' 'typedef' 'LPSTR' 'LPWSTR')
	}!
AXTypeInfoObject subclass: #AXTypeLibraryAnalyzer
	instanceVariableNames: 'attributes prefix packageName globalName constantsPoolName aliasMap typeAnalyzers'
	classVariableNames: 'TypeLibs'
	imports: #(#{AXAutomationErrors} #{Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!
AXTypeInfoAnalyzer subclass: #AXAPIInfoAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXTypeInfoAnalyzer subclass: #AXStructureTypeAnalyzer
	instanceVariableNames: ''
	classVariableNames: 'BuiltIns'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXTypeInfoAnalyzer subclass: #TKindAliasAnalyzer
	instanceVariableNames: ''
	classVariableNames: 'BaseTypes'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXTypeInfoAnalyzer subclass: #TKindCoclassAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXTypeInfoAnalyzer subclass: #TKindEnumAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXAPIInfoAnalyzer subclass: #AXInterfaceTypeAnalyzer
	instanceVariableNames: 'protocol isSource'
	classVariableNames: 'ReservedDispSelectors ReservedUnkSelectors'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXAPIInfoAnalyzer subclass: #TKindModuleAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXInterfaceTypeAnalyzer subclass: #TKindDispatchAnalyzer
	instanceVariableNames: ''
	classVariableNames: 'SpecialPropGets'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXInterfaceTypeAnalyzer subclass: #TKindInterfaceAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXStructureTypeAnalyzer subclass: #TKindRecordAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXStructureTypeAnalyzer subclass: #TKindUnionAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
COMFunction subclass: #DispFunction
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Win32Errors})
	classInstanceVariableNames: ''
	classConstants: {}!
COMInterfaceImp subclass: #AXDispatchImpAbstract
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors} #{Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!
AXDispatchImpAbstract subclass: #AXDualImp
	instanceVariableNames: 'interface piTypeInfo locale'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
AXDualImp subclass: #AXForwardingDualImp
	instanceVariableNames: 'interfaceClass server'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
COMEnumerator subclass: #COMVariantEnumerator
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #ICreateErrorInfo
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #IDispatch
	instanceVariableNames: 'typeInfo dispatchImplementor'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #IPerPropertyBrowsing
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #IProvideClassInfo
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #IRecordInfo
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #ITypeComp
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #ITypeInfo
	instanceVariableNames: 'attributes'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
IUnknown subclass: #ITypeLib
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
IEnumXXXX subclass: #IEnumVARIANT
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
IProvideClassInfo subclass: #IProvideClassInfo2
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
ITypeInfo subclass: #ITypeInfo2
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
ITypeLib subclass: #ITypeLib2
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
GenericExternalArray subclass: #SAFEARRAY
	instanceVariableNames: 'data start recordInfo'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cbElements' -> 16r4.
		'_OffsetOf_cDims' -> 16r0.
		'_OffsetOf_cLocks' -> 16r8.
		'_OffsetOf_fFeatures' -> 16r2.
		'_OffsetOf_pvData' -> 16rC.
		'_OffsetOf_rgsabound' -> 16r10
	}!
DOUBLE subclass: #DATE
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
SWORD subclass: #VARIANT_BOOL
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
LPVOID subclass: #LPBSTR
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OLEStructure subclass: #AbstractELEMDESC
	instanceVariableNames: 'owner tdesc'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_tdescElem' -> 16r0
	}!
OLEStructure subclass: #CURRENCY
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cy' -> 16r0
	}!
OLEStructure subclass: #CUSTDATAITEM
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_guid' -> 16r0.
		'_OffsetOf_varValue' -> 16r10
	}!
OLEStructure subclass: #DECIMAL
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_hi32' -> 16r4.
		'_OffsetOf_lo64' -> 16r8.
		'_OffsetOf_scale' -> 16r2.
		'_OffsetOf_sign' -> 16r3.
		'_OffsetOf_wReserved' -> 16r0
	}!
OLEStructure subclass: #DISPPARAMS
	instanceVariableNames: 'args vargs dispids'
	classVariableNames: 'ZeroArgs'
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cArgs' -> 16r8.
		'_OffsetOf_cNamedArgs' -> 16rC.
		'_OffsetOf_rgdispidNamedArgs' -> 16r4.
		'_OffsetOf_rgvarg' -> 16r0
	}!
OLEStructure subclass: #FONTDESC
	instanceVariableNames: 'name'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cySize' -> 16r8.
		'_OffsetOf_dwSize' -> 16r0.
		'_OffsetOf_fItalic' -> 16r14.
		'_OffsetOf_fStrikethrough' -> 16r1C.
		'_OffsetOf_fUnderline' -> 16r18.
		'_OffsetOf_lpstrName' -> 16r4.
		'_OffsetOf_sCharset' -> 16r12.
		'_OffsetOf_sWeight' -> 16r10
	}!
OLEStructure subclass: #IDLDESC
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_dwReserved' -> 16r0.
		'_OffsetOf_wIDLFlags' -> 16r4
	}!
OLEStructure subclass: #PARAMDESC
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_pparamdescex' -> 16r0.
		'_OffsetOf_wParamFlags' -> 16r4
	}!
OLEStructure subclass: #PARAMDESCEX
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cBytes' -> 16r0.
		'_OffsetOf_varDefaultValue' -> 16r8
	}!
OLEStructure subclass: #SAFEARRAYBOUND
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cElements' -> 16r0.
		'_OffsetOf_lLbound' -> 16r4
	}!
OLEStructure subclass: #TLIBATTR
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_guid' -> 16r0.
		'_OffsetOf_lcid' -> 16r10.
		'_OffsetOf_syskind' -> 16r14.
		'_OffsetOf_wLibFlags' -> 16r1C.
		'_OffsetOf_wMajorVerNum' -> 16r18.
		'_OffsetOf_wMinorVerNum' -> 16r1A
	}!
OLEStructure subclass: #TYPEDESC
	instanceVariableNames: 'owner classDesc typeInfo'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_hreftype' -> 16r0.
		'_OffsetOf_lpadesc' -> 16r0.
		'_OffsetOf_lptdesc' -> 16r0.
		'_OffsetOf_vt' -> 16r4.
		'VTIndirections' -> #[0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
	}!
AbstractELEMDESC subclass: #ARRAYDESC
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cDims' -> 16r8.
		'_OffsetOf_rgbounds' -> 16rC
	}!
AbstractELEMDESC subclass: #ELEMDESC
	instanceVariableNames: 'param'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_paramdesc' -> 16r8
	}!
OLEFinalizableStructure subclass: #AXRecord
	instanceVariableNames: 'recordInfo owner'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OLEFinalizableStructure subclass: #AXTypeInfoStructure
	instanceVariableNames: 'analyzer'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
OLEFinalizableStructure subclass: #CUSTDATA
	instanceVariableNames: 'contents'
	classVariableNames: 'WellKnownCustomAttributes'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cCustData' -> 16r0.
		'_OffsetOf_prgCustData' -> 16r4
	}!
OLEFinalizableStructure subclass: #VARIANT
	instanceVariableNames: 'data'
	classVariableNames: 'Unspecified'
	imports: #(#{AXAutomationConstants} #{AXAutomationErrors} #{Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_dblVal' -> 16r8.
		'_OffsetOf_vt' -> 16r0.
		'_OffsetOf_wReserved1' -> 16r2.
		'_OffsetOf_wReserved2' -> 16r4.
		'_OffsetOf_wReserved3' -> 16r6.
		'VTClasses' -> #(#{UndefinedObject} nil #{SWORD} #{SDWORD} #{FLOAT} #{DOUBLE} #{CURRENCY} #{DATE} #{BSTR} #{IDispatch} #{HRESULT} #{VARIANT_BOOL} #{VARIANT} #{IUnknown} #{DECIMAL} nil #{SBYTE} #{BYTE} #{WORD} #{DWORD} #{LARGE_INTEGER} #{ULARGE_INTEGER} #{SDWORD} #{DWORD} #{VOID} #{HRESULT} #{ExternalAddress} #{SAFEARRAY} #{ExternalArray} #{AXRecord} #{String} #{Utf16String} nil nil nil nil #{ExternalStructure} nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #{FILETIME} nil nil nil nil nil nil #{DWORD} #{CLSID}).
		'VTNames' -> #(#nil #null #sword #sdword #float #double #cy #date #bstr #dispatch #hresult #varbool #variant #unknown #decimal #badVarType #sbyte #byte #word #dword #sqword #qword #sdword #dword #void #hresult #lpvoid #safearray #carray #typedef #lpstr #lpwstr #badVarType #badVarType #badVarType #badVarType #struct #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #filetime #blob #stream #storage #streamed_object #stored_object #blob_object #cf #clsid)
	}!
AXTypeInfoStructure subclass: #AXMemberDesc
	instanceVariableNames: 'index customAttributes documentation'
	classVariableNames: ''
	imports: #(#{AXAutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
AXTypeInfoStructure subclass: #TYPEATTR
	instanceVariableNames: 'piTypeInfo'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cbAlignment' -> 16r34.
		'_OffsetOf_cbSizeInstance' -> 16r24.
		'_OffsetOf_cbSizeVft' -> 16r32.
		'_OffsetOf_cFuncs' -> 16r2C.
		'_OffsetOf_cImplTypes' -> 16r30.
		'_OffsetOf_cVars' -> 16r2E.
		'_OffsetOf_dwReserved' -> 16r14.
		'_OffsetOf_guid' -> 16r0.
		'_OffsetOf_idldescType' -> 16r44.
		'_OffsetOf_lcid' -> 16r10.
		'_OffsetOf_lpstrSchema' -> 16r20.
		'_OffsetOf_memidConstructor' -> 16r18.
		'_OffsetOf_memidDestructor' -> 16r1C.
		'_OffsetOf_tdescAlias' -> 16r3C.
		'_OffsetOf_typekind' -> 16r28.
		'_OffsetOf_wMajorVerNum' -> 16r38.
		'_OffsetOf_wMinorVerNum' -> 16r3A.
		'_OffsetOf_wTypeFlags' -> 16r36
	}!
AXMemberDesc subclass: #FUNCDESC
	instanceVariableNames: 'names arguments outputIndices retvalIndex methodName'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_callconv' -> 16r14.
		'_OffsetOf_cParams' -> 16r18.
		'_OffsetOf_cParamsOpt' -> 16r1A.
		'_OffsetOf_cScodes' -> 16r1E.
		'_OffsetOf_elemdescFunc' -> 16r20.
		'_OffsetOf_funckind' -> 16rC.
		'_OffsetOf_invkind' -> 16r10.
		'_OffsetOf_lprgelemdescParam' -> 16r8.
		'_OffsetOf_lprgscode' -> 16r4.
		'_OffsetOf_memid' -> 16r0.
		'_OffsetOf_oVft' -> 16r1C.
		'_OffsetOf_wFuncFlags' -> 16r30
	}!
AXMemberDesc subclass: #VARDESC
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_elemdesc' -> 16rC.
		'_OffsetOf_lpstrSchema' -> 16r4.
		'_OffsetOf_lpvarValue' -> 16r8.
		'_OffsetOf_memid' -> 16r0.
		'_OffsetOf_oInst' -> 16r8.
		'_OffsetOf_varkind' -> 16r20.
		'_OffsetOf_wVarFlags' -> 16r1C
	}!

"Loose Methods"!

!BOOL class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !
!BOOL class categoriesFor: #typeName!constants!private! !

!Boolean methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^VARIANT fromBoolean: self! !
!Boolean categoriesFor: #asVariant!converting!public! !

!BOOLEAN class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !
!BOOLEAN class categoriesFor: #typeName!constants!private! !

!BSTR methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self elementClass: SWORD!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^VARIANT fromString: self! !
!BSTR categoriesFor: #asSAFEARRAY!converting!public! !
!BSTR categoriesFor: #asVariant!converting!public! !

!BSTR class methodsFor!

fromObject: anObject
	^self fromString: anObject!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY length: length vt: self vt elementClass: self!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_BSTR! !
!BSTR class categoriesFor: #fromObject:!instance creation!public! !
!BSTR class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!BSTR class categoriesFor: #typeName!constants!private! !
!BSTR class categoriesFor: #vt!constants!public! !

!BYTE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#byte!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI1! !
!BYTE class categoriesFor: #typeName!constants!private! !
!BYTE class categoriesFor: #vt!constants!public! !

!ByteArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self elementClass: BYTE! !
!ByteArray categoriesFor: #asSAFEARRAY!converting!public! !

!ByteArray class methodsFor!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self name! !
!ByteArray class categoriesFor: #typeName!constants!private! !

!Character methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I2). This will fail for code points not in the BMP."

	^VARIANT new
		sword: self codePoint;
		yourself! !
!Character categoriesFor: #asVariant!converting!public! !

!CLSID class methodsFor!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY length: length 	vt: self vt elementClass: self!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_CLSID
! !
!CLSID class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!CLSID class categoriesFor: #vt!constants!public! !

!Collection methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self!

asVariant
	"Answer the VARIANT representation of the receiver (a SAFEARRAY of VARIANT)."

	^VARIANT fromCollection: self! !
!Collection categoriesFor: #asSAFEARRAY!converting!public! !
!Collection categoriesFor: #asVariant!converting!public! !

!COMInterface methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self class errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the object on which the receiver is an interface."

	^(self queryInterface: IProvideClassInfo) 
		ifNil: [self class coclassTypeInfoIfNone: [^exceptionHandler value]]
		ifNotNil: 
			[:ipc | 
			[AXTypeInfoAnalyzer onTypeInfo: ipc getClassInfo] on: HRESULTError
				do: [:ex | ^exceptionHandler value]]!

typeInfo
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^self typeInfoIfNone: [self class errorNoTypeInfo]!

typeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^(self coclassTypeInfoIfNone: [^exceptionHandler value]) defaultInterface! !
!COMInterface categoriesFor: #coclassTypeInfo!accessing!public! !
!COMInterface categoriesFor: #coclassTypeInfoIfNone:!accessing!public! !
!COMInterface categoriesFor: #typeInfo!accessing!public! !
!COMInterface categoriesFor: #typeInfoIfNone:!accessing!public! !

!COMInterface class methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler 
	"Answer any type information that exists for the object on which the receiver is the default interface.
	This link can only be made if the #clsid method is defined and a type library with the relevant
	information is available."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [tlb typeInfoForGuid: self clsid ifNone: [^exceptionHandler value]]!

errorNoTypeInfo
	"Private - Raise an exception to the effect that the receiver has no associated
	type information available."

	^self error: 'No type information available.'!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^anObject queryInterface: self!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver."

	^SAFEARRAY length: length interfaceClass: self!

registerDispinterface: anIID
	"Register the specified <IID> as another dispinterface (i.e. an IID implemented by IDispatch)."

	InterfaceClasses at: anIID put: IDispatch!

typeInfoIfNone: exceptionHandler
	"Answer an <AXInterfaceTypeAnalyzer> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [(tlb typeInfoForGuid: self guid ifNone: [^exceptionHandler value]) asImplType]!

typeLib
	"Answer an <AXTypeLibraryAnalyzer> on the receiver's type library,
	or nil if the receiver does not have a type library."

	^typeLib! !
!COMInterface class categoriesFor: #coclassTypeInfo!accessing!public! !
!COMInterface class categoriesFor: #coclassTypeInfoIfNone:!accessing!public! !
!COMInterface class categoriesFor: #errorNoTypeInfo!exceptions!private! !
!COMInterface class categoriesFor: #fromObject:!instance creation!public! !
!COMInterface class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!COMInterface class categoriesFor: #registerDispinterface:!adding!public! !
!COMInterface class categoriesFor: #typeInfoIfNone:!accessing!public! !
!COMInterface class categoriesFor: #typeLib!accessing!public! !

!Date methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	^self asParameter asFloat!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_DATE)."

	^self asSYSTEMTIME asVariant! !
!Date categoriesFor: #asFloat!converting!public! !
!Date categoriesFor: #asVariant!converting!public! !

!DateAndTime methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	^self asParameter asFloat!

asVariant
	"Answer the <VARIANT> representation of the receiver (a VT_DATE)."

	^self asSYSTEMTIME asVariant! !
!DateAndTime categoriesFor: #asFloat!converting!public! !
!DateAndTime categoriesFor: #asVariant!converting!public! !

!DOUBLE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#double!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_R8! !
!DOUBLE class categoriesFor: #typeName!constants!private! !
!DOUBLE class categoriesFor: #vt!constants!public! !

!DWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#dword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI4! !
!DWORD class categoriesFor: #typeName!constants!private! !
!DWORD class categoriesFor: #vt!constants!public! !

!ExternalAddress class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpvoid!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_PTR! !
!ExternalAddress class categoriesFor: #typeName!constants!private! !
!ExternalAddress class categoriesFor: #vt!constants!public! !

!ExternalArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver."

	^SAFEARRAY withAll: self elementClass: self elementClass!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_ARRAY|VT_XX)."

	^VARIANT fromCollection: self! !
!ExternalArray categoriesFor: #asSAFEARRAY!converting!public! !
!ExternalArray categoriesFor: #asVariant!converting!public! !

!ExternalArray class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_CARRAY! !
!ExternalArray class categoriesFor: #vt!constants!public! !

!ExternalHandle class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#handle! !
!ExternalHandle class categoriesFor: #typeName!constants!private! !

!ExternalInteger class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^self subclassResponsibility!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self subclassResponsibility! !
!ExternalInteger class categoriesFor: #typeName!constants!private! !
!ExternalInteger class categoriesFor: #vt!constants!private! !

!ExternalScalar methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^(VARIANT new)
		vt: (self vt bitOr: AXAutomationConstants.VT_BYREF);
		reference: self! !
!ExternalScalar categoriesFor: #asVariant!converting!public! !

!ExternalStructure methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Note that shis will be a reference to the receiver not a copy."

	^VARIANT new
		struct: self;
		yourself!

recordInfo
	"Answer an <IRecordInfo> on the receiver's type information."

	^self class recordInfo!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self class vt! !
!ExternalStructure categoriesFor: #asVariant!converting!public! !
!ExternalStructure categoriesFor: #recordInfo!accessing!public! !
!ExternalStructure categoriesFor: #vt!constants!private! !

!ExternalStructure class methodsFor!

classForGUID: aGUID ifNone: exceptionHandler
	"Private - Answer the <ExternalStructure> class (a subclass of the receiver) which
	represents the Record with <GUID>, aGUID, or if none is registered for that GUID
	then the result of evaluating the <niladicValuable>, exceptionHandler."

	^RecordClasses at: aGUID ifAbsent: exceptionHandler

	
!

clearGuid
	"Private - Set the receiver's GUID to be the null <GUID>.
	Override because we must retain our GUID for the table
	of record classes (only needed for ActiveX Automation)."

!

finalRelease
	"The last reference to the receiver (as a COM object) has been released.
	This is an opportunity to actively clean up, rather than passively waiting 
	for finalization which might is asynchronous and may never happen if the 
	object doesn't become garbage."

	"Override as necessary"!

fromAddress: address recordInfo: recInfo owner: owner
	"Answer a new subinstance of the receiver which references the structure
	described by the <IRecordInfo>, recInfo, at the specified address,
	which is owned by the Object, owner."


	^(self 
		classForGUID: recInfo guid 
		ifNone: [^AXRecord 
				fromAddress: address
				recordInfo: recInfo
				owner: owner])
		fromAddress: address!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^(self newBuffer)
		value: anObject;
		yourself!

GetField: pvData szFieldName: szFieldName pvarField: pvarField 
	"Implement the IRecordInfo::GetField() method for the UDT described by the receiver.

		HRESULT __stdcall GetField(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField);

	"

	| refInst hr |
	refInst := self fromAddress: pvData.
	"Help specifies that VariantClear is call on pvarField before copying, normally but just VariantInit, but ..."
	pvarField class clear: pvarField yourAddress.
	
	[pvarField value: (refInst getField: szFieldName).
	hr := 0	"S_OK"] on: MessageNotUnderstood
			do: [:x | hr := Win32Errors.E_INVALIDARG].
	^hr!

GetFieldNames: pcNames rgBstrNames: rgBstrNames
	"Implement the IRecordInfo::GetFieldNames() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNames(
			[in, out] unsigned long* pcNames,
			[out] BSTR* rgBstrNames);
	"

	| names |
	names := self getFieldNames.
	rgBstrNames isNull
		ifTrue: [pcNames value: names size]
		ifFalse: 
			[| namesArray maxNames end |
			maxNames := pcNames value.
			"rgBstrNames will be an LPVOID holding the address of the buffer, which is a sufficiently sized array of BSTR pointers"
			namesArray := DWORDArray fromAddress: rgBstrNames yourAddress length: maxNames.
			end := names size min: maxNames.
			1 to: end do: [:i | namesArray at: i put: (names at: i) asBSTR detach].
			end + 1 to: maxNames do: [:i | namesArray at: i put: 0].
			pcNames value: end].
	^0	"S_OK"!

GetFieldNoCopy: pvData szFieldName: szFieldName pvarField: pvarField ppvDataCArray: ppvDataCArray
	"Implement the IRecordInfo::GetFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNoCopy(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField,
			[out] void** ppvDataCArray);
	"

	^Win32Errors.E_NOTIMPL
!

GetGuid: pguid
	"Implement the IRecordInfo::GetGuid() method for the UDT described by the receiver.

		HRESULT __stdcall GetGuid(
			[out] GUID* pguid);
	"

	pguid value: self guid.
	^0 "S_OK"
!

GetName: pbstrName
	"Implement the IRecordInfo::GetName() method for the UDT described by the receiver,
	i.e. answer the name of the record via the <BSTR>* output parameter.

		HRESULT __stdcall GetName(
			[out] BSTR* pbstrName);
	"

	pbstrName value: self name asBSTR detach.
	^0 "S_OK"
!

GetSize: pcbSize
	"Implement the IRecordInfo::GetSize() method for the UDT described by the receiver.

		HRESULT __stdcall GetSize(
			[out] unsigned long* pcbSize);
	"
	
	pcbSize value: self byteSize.
	^0 "S_OK"!

GetTypeInfo: ppTypeInfo
	"Implement the IRecordInfo::GetTypeInfo() method for the UDT described by the receiver.

		HRESULT __stdcall GetTypeInfo(
			[out] ITypeInfo** ppTypeInfo);
	"

	| ti |
	ppTypeInfo value: 0.
	ti := self typeInfoIfNone: [^1 "S_FALSE"].
	ti addRef.
	ppTypeInfo value: ti yourAddress.
	^0 "S_OK"
!

initializeRegister
	"Private - Initialize the register of GUIDs to record classes."

	RecordClasses := LookupTable new

!

IsMatchingType: pRecordInfo
	"Implement the IRecordInfo::IsMatchingType() method for the UDT described by the receiver.

		long __stdcall IsMatchingType(
			[in] IRecordInfo* pRecordInfo);
	"

	^(self guid = pRecordInfo guid) asParameter!

newSAFEARRAY: length 
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	| vt |
	^(vt := self vt) == AXAutomationConstants.VT_RECORD 
		ifTrue: [SAFEARRAY length: length recordClass: self]
		ifFalse: 
			[SAFEARRAY 
				length: length
				vt: vt
				elementClass: self]!

pointerFieldType
	"Answer the <ExternalField> class to represent pointers to this external type with the
	one indirection."

	^PointerField!

PutField: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutField() method for the UDT described by the receiver.

		HRESULT __stdcall PutField(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	| refInst value |
	refInst := self fromAddress: pvData.
	wFlags = AXAutomationConstants.INVOKE_PROPERTYPUT
		ifTrue: 
			[| fieldValue |
			fieldValue := [refInst getField: szFieldName] on: MessageNotUnderstood
						do: [:x | ^Win32Errors.E_INVALIDARG].
			value := pvarField isDispatch ifTrue: [pvarField dispatch value] ifFalse: [pvarField value].
			(fieldValue isKindOf: IDispatch)
				ifTrue: 
					[fieldValue isNull ifTrue: [^Win32Errors.E_POINTER].
					fieldValue value: value]
				ifFalse: [refInst setField: szFieldName value: value]]
		ifFalse: 
			[wFlags = AXAutomationConstants.INVOKE_PROPERTYPUTREF
				ifTrue: [value := pvarField value]
				ifFalse: [^Win32Errors.E_INVALIDARG]].
	^
	[refInst setField: szFieldName value: value.
	0	"S_OK"] on: MessageNotUnderstood
			do: [:x | Win32Errors.E_INVALIDARG]!

PutFieldNoCopy: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall PutFieldNoCopy(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	^Win32Errors.E_NOTIMPL
!

queryInterface: anInterfaceClass
	"Answer a new interface which supports the specified interface protocol
	(usually a class), or nil if the receiver does not support the interface."

	^self queryInterface: anInterfaceClass ifNone: []
!

queryInterface: anInterfaceClass ifNone: exceptionHandler
	"Answer a new interface pointer which supports the specified interface protocol
	(usually a class). If the receiver does not support the interface, answer the
	result of evaluating the niladic valuable, exceptionHandler."

	| class |
	class := self supportedInterfaces 
		detect: [:ic | ic supportsInterface: anInterfaceClass] 
		ifNone: [^exceptionHandler value].
	^class on: self implementor: self
!

RecordClear: pvExisting
	"Implement the IRecordInfo::RecordClear() method for the UDT described by the receiver.
	Clearing down a record involves freeing any of the fields that need to be finalized, it does
	not include releasing the memory owned by the record.

		HRESULT __stdcall RecordClear(
			[in] void* pvExisting);
	"

	self clear: pvExisting.
	^0 "S_OK"
!

RecordCopy: pvExisting pvNew: pvNew
	"Implement IRecordInfo::RecordCopy() method for the UDT described by the receiver.
	Copy an existing area of memory occuppied by a record of the receiver's type to a new
	location. Relies on a correct implementation of #copy which copies any pointed at
	structures which should not be shared.

		HRESULT __stdcall RecordCopy(
			[in] void* pvExisting,
			[out] void* pvNew);
	"

	| ref |
	ref := self fromAddress: pvExisting.
	pvNew 
		replaceFrom: 1
		to: ref byteSize
		with: ref copy detach
		startingAt: 1.
	^0 "S_OK"!

RecordCreate 
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver
	Create a new record of the receiver's type in COM task memory.

		void* __stdcall RecordCreate();
	"

	^(COMTaskMemory new: self byteSize) detach
!

RecordCreateCopy: pvSource ppvDest: ppvDest
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver

		HRESULT __stdcall RecordCreateCopy(
			[in] void* pvSource,
			[out] void** ppvDest);
	"

	| pv |
	pv := self RecordCreate.
	ppvDest value: pv.
	pv isNull ifTrue: [^Win32Errors.E_OUTOFMEMORY].
	^self RecordCopy: pvSource pvNew: pv!

RecordDestroy: pvRecord
	"Implement the RecordDestroy() method for the UDT described by the receiver.
	Free up a record of the receiver's type previously created with RecordCreate().

		HRESULT __stdcall RecordDestroy(
			[in] void* pvRecord);
	"

	self RecordClear: pvRecord.
	COMTaskMemory free: pvRecord.
	^0 "S_OK"!

recordInfo
	"Answer an <IRecordInfo> describing the receiver's structure class.
	Note that we attempt to use the system provided implementation, but as this is frequently 
	unavailable (even for the DX-7 libraries which require extensive use of IRecordInfo)
	we must also be able to implement it ourselves."

	| ti ri |
	ti := self typeInfoIfNone: [].
	ri := ti notNil ifTrue: [ti recordInfoIfNone: []].
	^ri ifNil: [IRecordInfo on: self]!

RecordInit: pvNew
	"Implement the IRecordInfo::RecordInit() method for the UDT described by the receiver.
	Initialize a new empty buffer for a record of the receiver's type. This implementation is the
	simplest possible - it just zeros the whole area.

		HRESULT __stdcall RecordInit(
			[out] void* pvNew);
	"

	self init: pvNew.
	^0 "S_OK"
!

registerSubclasses
	"(Re)Register the receiver's subclasses as record classes with
	their appropriate GUIDs. This is intended as a helper function when
	developing, and has no run-time significance.

		self registerSubclasses
	"

	self initializeRegister.
	self allSubclassesDo: [:c | c register]!

supportedInterfaces
	"Private - Answer the set of interface classes supported by the receiver.
	Implementation Note: We aren't expecting that the implementation of IRecordInfo we provide will actually
	be used for getting and setting the values of fields in UDTs, but mainly provide it to make up for the 
	fact that the one type library we've so far experienced which makes heavy use of UDTs (i.e. the DX-7 VB
	library) does not contain sufficient information (mainly GUIDs) to allow the system implementation of
	IRecordInfo to be constructed on the ITypeInfo's of the various structures defined therein. This suggests
	that VB doesn't use the system implementation itself, as otherwise the type library would be useless. Also
	it seems that DX-7 actually ignores the IRecordInfo (perhaps not surprisingly for a C library), so it is only 
	really needed in order to create VT_RECORD SAFEARRAYs and VARIANTs."

	^#(##(IRecordInfo))!

typeInfo
	"Answer an <ITypeInfo> on the receiver's type information."

	^self typeInfoIfNone: [self error: 'No type information available']!

typeInfoIfNone: exceptionHandler
	"Answer an <ITypeInfo> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| assoc |
	^(assoc := self libraryAndIndex) isNil
		ifTrue: [exceptionHandler value]
		ifFalse: [assoc key typeInfoAt: assoc value]!

typeLib
	"Answer an <ITypeLib> on the receiver's type library,
	or <nil> if the receiver does not have a type library."

	| libAndIndex |
	libAndIndex := self libraryAndIndex.
	^libAndIndex isNil ifFalse: [libAndIndex key]!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	Generally speaking this is the class name."

	^self name!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_RECORD! !
!ExternalStructure class categoriesFor: #classForGUID:ifNone:!enquiries!private! !
!ExternalStructure class categoriesFor: #clearGuid!accessing!private! !
!ExternalStructure class categoriesFor: #finalRelease!public!realizing/unrealizing! !
!ExternalStructure class categoriesFor: #fromAddress:recordInfo:owner:!instance creation!public! !
!ExternalStructure class categoriesFor: #fromObject:!instance creation!public! !
!ExternalStructure class categoriesFor: #GetField:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #GetFieldNames:rgBstrNames:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #GetGuid:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #GetName:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #GetSize:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #GetTypeInfo:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #initializeRegister!initializing!private! !
!ExternalStructure class categoriesFor: #IsMatchingType:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!ExternalStructure class categoriesFor: #pointerFieldType!constants!private! !
!ExternalStructure class categoriesFor: #PutField:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #PutFieldNoCopy:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #queryInterface:!accessing-interfaces!public! !
!ExternalStructure class categoriesFor: #queryInterface:ifNone:!accessing!accessing-interfaces!public! !
!ExternalStructure class categoriesFor: #RecordClear:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #RecordCopy:pvNew:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #RecordCreate!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #RecordCreateCopy:ppvDest:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #RecordDestroy:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #recordInfo!accessing!public! !
!ExternalStructure class categoriesFor: #RecordInit:!COM Interfaces-IRecordInfo!public! !
!ExternalStructure class categoriesFor: #registerSubclasses!initializing!public! !
!ExternalStructure class categoriesFor: #supportedInterfaces!constants!private! !
!ExternalStructure class categoriesFor: #typeInfo!accessing!public! !
!ExternalStructure class categoriesFor: #typeInfoIfNone:!accessing!public! !
!ExternalStructure class categoriesFor: #typeLib!accessing!public! !
!ExternalStructure class categoriesFor: #typeName!constants!private! !
!ExternalStructure class categoriesFor: #vt!constants!public! !

!FILETIME class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_FILETIME! !
!FILETIME class categoriesFor: #vt!constants!public! !

!Float methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8)."

	^VARIANT fromFloat: self! !
!Float categoriesFor: #asVariant!converting!public! !

!FLOAT class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#float!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_R4! !
!FLOAT class categoriesFor: #typeName!constants!private! !
!FLOAT class categoriesFor: #vt!constants!public! !

!Fraction methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8).
	Note that precision may be lost."

	^self asFloat asVariant! !
!Fraction categoriesFor: #asVariant!converting!public! !

!GUID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self name! !
!GUID class categoriesFor: #typeName!constants!private! !

!HRESULT class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#hresult!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^AXAutomationConstants.VT_ERROR! !
!HRESULT class categoriesFor: #typeName!constants!private! !
!HRESULT class categoriesFor: #vt!constants!private! !

!IErrorInfo class methodsFor!

fromEXCEPINFO: excepInfo guid: id
	"Answer a new instance of the receiver on a system extended error object
	with details from the <EXCEPINFO> structure, excepInfo."

	^(ICreateErrorInfo fromEXCEPINFO: excepInfo guid: id) errorInfo!

source: sourceString description: descriptionString helpContext: anInteger helpFile: helpFilePath guid: aGUID
	"Answer a new instance of the receiver encapsulating all of the specified details.
		ice := self source: 'Dolphin' description: 'It is all going horribly wrong' helpContext: 1 helpFile: nil guid: GUID newUnique.
	"

	| ice |
	ice := ICreateErrorInfo new.
	ice SetSource: sourceString.
	ice SetDescription: descriptionString.
	ice SetHelpContext: anInteger.
	ice SetHelpFile: helpFilePath.
	ice SetGuid: aGUID.
	^ice errorInfo

! !
!IErrorInfo class categoriesFor: #fromEXCEPINFO:guid:!instance creation!public! !
!IErrorInfo class categoriesFor: #source:description:helpContext:helpFile:guid:!instance creation!public! !

!INT_PTR class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#intptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [AXAutomationConstants.VT_I8] ifFalse: [AXAutomationConstants.VT_I4]! !
!INT_PTR class categoriesFor: #typeName!constants!private! !
!INT_PTR class categoriesFor: #vt!constants!public! !

!Integer methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I4, VT_I8, or VT_UI8)."

	^self subclassResponsibility! !
!Integer categoriesFor: #asVariant!converting!public! !

!IUnknown methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver."

	^VARIANT fromUnknown: self! !
!IUnknown categoriesFor: #asVariant!converting!public! !

!IUnknown class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UNKNOWN! !
!IUnknown class categoriesFor: #vt!constants!public! !

!LARGE_INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sqword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I8! !
!LARGE_INTEGER class categoriesFor: #typeName!constants!private! !
!LARGE_INTEGER class categoriesFor: #vt!constants!public! !

!LargeInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I8).
	It is an error if the receiver is too large to be represented in 64-bits."

	^VARIANT fromLargeInteger: self! !
!LargeInteger categoriesFor: #asVariant!converting!public! !

!Locale methodsFor!

variantBool: aBoolean
	^self subclassResponsibility! !
!Locale categoriesFor: #variantBool:!constants!public! !

!LPVOID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	#todo "Is this right?".
	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	#todo "Is this right?".
	^AXAutomationConstants.VT_VOID! !
!LPVOID class categoriesFor: #typeName!constants!private! !
!LPVOID class categoriesFor: #vt!constants!public! !

!OLEAutLibrary methodsFor!

clearCustData: pCustData
	"WINOLEAUTAPI_(void) ClearCustData(LPCUSTDATA pCustData);"

	<stdcall: void ClearCustData CUSTDATA*>
	^self invalidCall: _failureCode!

createErrorInfo: pperrinfo
	"Loads _and registers_ a type library from the specified path.

		HRESULT CreateErrorInfo(
			ICrateErrorInfo**		pperrinfo
		)"

	<stdcall: hresult CreateErrorInfo lppvoid>
	^self invalidCall: _failureCode!

getRecordInfoFromTypeInfo: pTypeInfo ppRecInfo: ppRecInfo
	"Create a RecordInfo object on the specified ITypeInfo, and answer an <IRecordInfo> on it.
		HRESULT GetRecordInfoFromTypeInfo( 
			ITypeInfo  pTypeInfo,  
			IRecordInfo** ppRecInfo);"

	"Implementation Note: Answer an integer HRESULT code rather than raising an exception
	as it is most unusual for this call to succeed it would seem!!"

	<stdcall: sdword GetRecordInfoFromTypeInfo ITypeInfo* IRecordInfo**>
	^self invalidCall: _failureCode!

lHashValOfNameSys: syskind lcid: lcid szName: szNem
	"Calculate the hash value of a string.

		ULONG LHashValOfNameSys(
		SYSKIND syskind <>, 
		LCID lcid <>, 
		const OLECHAR FAR* szName <> ); 
		)"

	<stdcall: dword LHashValOfNameSys sdword sdword lpwstr>
	^self invalidCall: _failureCode!

loadRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid pptlib: pptlib
	"Load a type library from the registry entries corresponding to the specified LIBID,
	version information, and LCID.

		HRESULT LoadRegTypeLib(      REFGUID rguid, 
			unsigned short wVerMajor, 
			unsigned short wVerMinor, 
			LCID lcid, 
			ITypeLib FAR* FAR* pptlib 
		); "

	<stdcall: hresult LoadRegTypeLib guid* word word dword lppvoid>
	^self invalidCall: _failureCode!

loadTypeLib: szFileName pptlib: lplptlib
	<stdcall: hresult LoadTypeLib lpwstr lppvoid>
	^self invalidCall: _failureCode!

loadTypeLibEx: szFileName regkind: regkind pptlib: lplptlib
	"Loads, and optionally registers, a type library from the specified path.

		HRESULT LoadTypeLibEx(
			OLECHAR FAR*		szFileName,
			REGKIND				regkind,
			ITypeLib FAR* FAR*	pptlib
		)"

	<stdcall: hresult LoadTypeLibEx lpwstr sdword lppvoid>
	^self invalidCall: _failureCode!

oleCreateFontIndirect: pFontDesc riid: riid ppvObj: ppvObj
	"Create an OLE font object matching the supplied <FONTDESC>. 

		STDAPI OleCreateFontIndirect(
			FONTDESC* pFontDesc,
			REFIID riid,
			VOID** ppvObj);
 	"

	<stdcall: hresult OleCreateFontIndirect FONTDESC* guid* void**>
	^self invalidCall: _failureCode!

queryPathOfRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid lpbstrPathName: lpbstrPathName
	"Determine the path of a registered type library.
	Implementation Note: It is quite a common occurrence that the library not be registered
	on a particular machine, and using this function is the best way to find that out, therefore
	we define the return code as an integer rather than an HRESULT to avoid getting an
	exception.

	HRESULT QueryPathOfRegTypeLib(
		REFGUID guid,
		unsigned short wVerMajor,
		unsigned short wVerMinor,
		LCID lcid,
		LPBSTR lpbstrPathName);"

	<stdcall: sdword QueryPathOfRegTypeLib guid* word word dword bstr*>
	^self invalidCall: _failureCode!

registerTypeLib: ptlib wszFullPath: wszFullPath wszHelpDir: wszHelpDir
	"Invoke the RegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Adds information about a type library to the system registry

		HRESULT __stdcall RegisterTypeLib(
			ITypeLib* ptlib,
			LPWSTR wszFullPath,
			LPWSTR wszHelpDir);"

	<stdcall: sdword RegisterTypeLib ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

registerTypeLibForUser: ptlib szFullPath: szFullPath szHelpDir: szHelpDir
	"Invoke the RegisterTypeLibForUser() function of the module wrapped by the receiver.
	Helpstring: Registers a type library for use by the calling user.

		HRESULT __stdcall RegisterTypeLibForUser(
			ITypeLib* ptlib,
			LPWSTR szFullPath,
			LPWSTR szHelpDir);"

	<stdcall: hresult RegisterTypeLibForUser ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

safeArrayAccessData: psa ppvData: ppvData
	"Increment the lock count of an array, and return a pointer to the array data
	through the <ExternalAddress>, ppvData.

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayAccessData SAFEARRAY* lppvoid>
	^self invalidCall: _failureCode!

safeArrayCopy: psa ppsaout: ppsaout
	"Create a copy of a SAFEARRAY.

		HRESULT SafeArrayCopy( 
			SAFEARRAY *  psa,          
			SAFEARRAY **  ppsaOut  
		);"

	<stdcall: hresult SafeArrayCopy SAFEARRAY* SAFEARRAY**>
	^self invalidCall: _failureCode!

safeArrayCreateEx: vt cDims: cDims rgsabound: rgsabound pvExtra: anExternalAddressOfNil
	<stdcall: SAFEARRAY* SafeArrayCreateEx word sdword SAFEARRAYBOUND* lpvoid>
	^self invalidCall: _failureCode!

safeArrayCreateVectorEx: vt lLbound: lLbound cElements: cElements pvExtra: pvExtra
	"Create a one-dimensional SAFEARRAY.

		SAFEARRAY SafeArrayCreateVectorEx( 
			VARTYPE  vt,             
			long  lLbound,           
			unsigned int  cElements ,
			LPVOID pvExtra
		);"

	<stdcall: SAFEARRAY* SafeArrayCreateVectorEx sword sdword dword lpvoid>
	^self invalidCall: _failureCode!

safeArrayDestroy: psa
	"Tidy away a SAFEARRAY. May involve releasing objects, etc.

		HRESULT SafeArrayDestroy(SAFEARRAY FAR*  psa);
	"

	<stdcall: sdword SafeArrayDestroy SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetDim: psa
	"Answer the number of dimensions in a SAFEARRAY.

		UINT SafeArrayGetDim(SAFEARRAY FAR*  psa);
	"

	<stdcall: dword SafeArrayGetDim SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetElement: psa rgIndices: rgIndices pv: pv
	"Answer an individual element of the receiver as identified by the array
	of indices, rgIndices, through the buffer, pv.

		HRESULT SafeArrayGetElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayGetElement SAFEARRAY* sdword* lppvoid>
	^self invalidCall: _failureCode!

safeArrayGetIID: psa pguid: pguid
	"Get the IID of the FADF_HAVEIID safe array, psa, storing it 
	into the output parameter, pvt.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			GUID* pguid
		);"

	<stdcall: hresult SafeArrayGetIID SAFEARRAY* guid*>
	^self invalidCall: _failureCode!

safeArrayGetLBound: psa nDim: nDim plLbound: plLbound
	"Answer the lower bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <SDWORD> parameter, plLbound..

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayGetLBound SAFEARRAY* dword sdword*>
	^self invalidCall: _failureCode!

safeArrayGetRecordInfo: aSAFEARRAY prinfo: anIRecordInfo
	<stdcall: hresult SafeArrayGetRecordInfo SAFEARRAY* IRecordInfo**>
	^self invalidCall: _failureCode!

safeArrayGetUBound: psa nDim: nDim plUbound: plUbound
	"Answer the upper bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <SDWORD> parameter, plUbound..

		HRESULT SafeArrayGetUBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plUbound
		);"

	<stdcall: hresult SafeArrayGetUBound SAFEARRAY* dword sdword*>
	^self invalidCall: _failureCode!

safeArrayGetVartype: psa pvt: pvt
	"Get the VARTYPE of the safe array, psa, storing it into the output parameter, pvt.

		HRESULT SafeArrayGetVartype(
			SAFEARRAY FAR* psa,
			VARTYPE* vt
		);"

	<stdcall: hresult SafeArrayGetVartype SAFEARRAY* word*>
	^self invalidCall: _failureCode!

safeArrayPtrOfIndex: aSAFEARRAY rgIndices: aSDWORDArray ppvData: anExternalAddress
	<stdcall: hresult SafeArrayPtrOfIndex SAFEARRAY* sdword* lppvoid>
	^self invalidCall: _failureCode!

safeArrayPutElement: psa rgIndices: rgIndices pv: pv
	"Replease the individual element of the receiver as identified by the array
	of indices, rgIndices, with the contents of the buffer pointed at by the
	<externalAddress>, pv.

		HRESULT SafeArrayPutElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayPutElement SAFEARRAY* sdword* lpvoid>
	^self invalidCall: _failureCode!

safeArrayRedim: psa psaboundNew: psaboundNew
	"Resize the least significant bound of the SAFEARRAY, psa,
	to the lower bound and element count specified in the 
	SAFEARRAYBOUND, psaboundNew.

		HRESULT SafeArrayRedim(
			SAFEARRAY FAR* psa,
			SAFEARRAYBOUND psaboundNew
		);"

	<stdcall: hresult SafeArrayRedim SAFEARRAY* SAFEARRAYBOUND*>
	^self invalidCall: _failureCode!

safeArraySetIID: psa pguid: pguid
	"Set the IID of the FADF_HAVEIID safe array, psa.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			REFGUID pguid
		);"

	<stdcall: hresult SafeArraySetIID SAFEARRAY* REFGUID>
	^self invalidCall: _failureCode!

safeArrayUnaccessData: psa
	"Reverse a previous SafeArrayAccessData.

		HRESULT SafeArrayUnaccessData(SAFEARRAY FAR*  psa);
	"

	<stdcall: hresult SafeArrayUnaccessData SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayUnlock: psa
	<stdcall: hresult SafeArrayUnlock SAFEARRAY*>
	^self invalidCall: _failureCode!

setErrorInfo: dwReserved perrinfo: perrinfo
	"Set the current <IErrorInfo> pointer for the calling thread.

		HRESULT SetErrorInfo(
			DWORD			dwReserved,
			IErrorInfo*		perrinfo
		)"

	<stdcall: hresult GetErrorInfo dword IErrorInfo*>
	^self invalidCall: _failureCode!

systemTimeToVariantTime: lpSystemTime pvtime: pvtime
	"Convert the <SYSTEMTIME>, lpSystemTime, to an OLE format <DATE>,
	answering whether the conversion succeeded.

		INT SystemTimeToVariantTime(
			SYSTEMTIME  lpSystemTime  
			double  *pvtime           
		);"

	<stdcall: bool SystemTimeToVariantTime SYSTEMTIME* double*>
	^self invalidCall: _failureCode!

unRegisterTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid syskind: syskind
	"Invoke the UnRegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Removes type library information from the system registry.

		HRESULT __stdcall UnRegisterTypeLib(
			GUID* rguid,
			unsigned short wVerMajor,
			unsigned short wVerMinor,
			unsigned long lcid,
			SYSKIND syskind);"

	<stdcall: hresult UnRegisterTypeLib guid* word word dword sdword>
	^self invalidCall: _failureCode!

varBstrFromBool: boolIn lcid: lcid dwFlags: dwFlags pbstrOut: pbstrOut
	"HRESULT VarBstrFromBool(
		  VARIANT_BOOL boolIn,
		  LCID         lcid,
		  ULONG        dwFlags,
		  BSTR         *pbstrOut
		);
	"

	<stdcall: hresult VarBstrFromBool sword dword dword bstr*>
	^self invalidCall: _failureCode!

varCmp: pvarLeft pvarRight: pvarRight lcid: lcid dwFlags: dwFlags
	"Answer a comparison result between the two VARIANT arguments.

		HRESULT VarCmp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LCID lcid, ULONG dwFlags);
	"

	<stdcall: hresult VarCmp variant* variant* dword dword>
	^self invalidCall: _failureCode!

varDateFromStr: strIn lcid: lcid dwFlags: dwFlags pdateOut: aFloat
	"Convert from a string date representation to the OLE Automation date type,
	according to the users regional settings.

		HRESULT VarDateFromStr(OLECHAR* strIn, LCID lcid, DWORD dwFlags, DATE* pdateOut);"

	<stdcall: hresult VarDateFromStr lpwstr dword dword lpvoid>
	^self invalidCall: _failureCode!

variantChangeType: pvargDest pvarSrc: pvarSrc wFlags: wFlags vt: vt
	"Convert a variant from one type to another. 

		HRESULT VariantChangeType(
			VARIANTARG FAR* pvargDest, 
			VARIANTARG FAR* pvarSrc, 
			unsigned short wFlags, 
			VARTYPE vt 
		);"

	<stdcall: hresult VariantChangeType variant* variant* word sword>
	^self invalidCall: _failureCode!

variantChangeTypeEx: pvargDest pvarSrc: pvarSrc lcid: lcid wFlags: wFlags vt: vt
	"Converts a variant from one type to another, using an LCID.

		HRESULT VariantChangeTypeEx(
			VARIANTARG       	*pvargDest,
			const VARIANTARG *pvarSrc,
			LCID             		lcid,
			USHORT           	wFlags,
			VARTYPE          	vt
		);"

	<stdcall: hresult VariantChangeTypeEx variant* variant* dword word sword>
	^self invalidCall: _failureCode!

variantClear: pvarg
	"Free a VARIANT, performing any special clean up  required (such as 
	Release()ing an IUnknown/IDispatch).
	Implementation Note: As this is used to finalize VARIANTs and there
	is little we can do about a failure, we return an integer error code
	rather than automatically raising an exception.

		HRESULT VariantClear(VARIANTARG FAR* pvarg)"

	<stdcall: sdword VariantClear variant*>
	^self invalidCall: _failureCode!

variantCopy: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest.

		HRESULT VariantCopy(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopy variant* variant*>
	^self invalidCall: _failureCode!

variantCopyInd: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest,
	where the copy is guaranteed not to be a VT_BYREF.

		HRESULT VariantCopyInd(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopyInd variant* variant*>
	^self invalidCall: _failureCode!

variantInit: pvarg
	"Initialize a VARIANT - sets the type tag to VT_EMPTY, but does not zero the
	data part of the union.

		void VariantInit(VARIANTARG FAR* pvarg)"

	<stdcall: void VariantInit variant*>
	^self invalidCall: _failureCode!

variantTimeToSystemTime: vtime lpSystemTime: lpSystemTime
	"Convert the OLE format date-time, vtime, to a SYSTEMTIME,
	answering whether the conversion succeeded.

		INT VariantTimeToSystemTime( 
			double  vtime,              
			LPSYSTEMTIME  lpSystemTime  
		);"

	<stdcall: bool VariantTimeToSystemTime double SYSTEMTIME*>
	^self invalidCall: _failureCode! !
!OLEAutLibrary categoriesFor: #clearCustData:!Automation Functions-Error Handling API!public! !
!OLEAutLibrary categoriesFor: #createErrorInfo:!Automation Functions-Error Handling API!public! !
!OLEAutLibrary categoriesFor: #getRecordInfoFromTypeInfo:ppRecInfo:!OLE Functions-OLE!public! !
!OLEAutLibrary categoriesFor: #lHashValOfNameSys:lcid:szName:!Automation Functions-Type Compilation And Library!primitives!public! !
!OLEAutLibrary categoriesFor: #loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:!Automation Functions-Type Compilation And Library!public! !
!OLEAutLibrary categoriesFor: #loadTypeLib:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
!OLEAutLibrary categoriesFor: #loadTypeLibEx:regkind:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
!OLEAutLibrary categoriesFor: #oleCreateFontIndirect:riid:ppvObj:!OLE Functions-OLE!public! !
!OLEAutLibrary categoriesFor: #queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:!Automation Functions-Type Compilation And Library!public! !
!OLEAutLibrary categoriesFor: #registerTypeLib:wszFullPath:wszHelpDir:!Automation Functions-Type Compilation And Library!public! !
!OLEAutLibrary categoriesFor: #registerTypeLibForUser:szFullPath:szHelpDir:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
!OLEAutLibrary categoriesFor: #safeArrayAccessData:ppvData:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayCopy:ppsaout:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayCreateEx:cDims:rgsabound:pvExtra:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayCreateVectorEx:lLbound:cElements:pvExtra:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayDestroy:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayGetDim:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayGetElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayGetIID:pguid:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayGetLBound:nDim:plLbound:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayGetRecordInfo:prinfo:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayGetUBound:nDim:plUbound:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayGetVartype:pvt:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayPtrOfIndex:rgIndices:ppvData:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayPutElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayRedim:psaboundNew:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArraySetIID:pguid:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayUnaccessData:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #safeArrayUnlock:!Automation Functions-Array Manipulation!public! !
!OLEAutLibrary categoriesFor: #setErrorInfo:perrinfo:!Automation Functions-Error Handling API!public! !
!OLEAutLibrary categoriesFor: #systemTimeToVariantTime:pvtime:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
!OLEAutLibrary categoriesFor: #varBstrFromBool:lcid:dwFlags:pbstrOut:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #varCmp:pvarRight:lcid:dwFlags:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #varDateFromStr:lcid:dwFlags:pdateOut:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #variantChangeType:pvarSrc:wFlags:vt:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #variantChangeTypeEx:pvarSrc:lcid:wFlags:vt:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #variantClear:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #variantCopy:pvargSrc:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #variantCopyInd:pvargSrc:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #variantInit:!Automation Functions-Variant Manipulation!public! !
!OLEAutLibrary categoriesFor: #variantTimeToSystemTime:lpSystemTime:!Automation Functions-Variant Manipulation!public! !

!QWORD class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI8! !
!QWORD class categoriesFor: #vt!constants!public! !

!SBYTE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sbyte!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I1! !
!SBYTE class categoriesFor: #typeName!constants!private! !
!SBYTE class categoriesFor: #vt!constants!public! !

!ScaledDecimal methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Both VT_CY (currency) and VT_DECIMAL types convert to ScaledDecimals
	but the latter has a wider (64-bit unsigned) range and a variable scale, so it
	is more likely to suit."

	^VARIANT new 
		decimal: self;
		yourself! !
!ScaledDecimal categoriesFor: #asVariant!converting!public! !

!SDWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sdword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I4! !
!SDWORD class categoriesFor: #typeName!constants!private! !
!SDWORD class categoriesFor: #vt!constants!public! !

!SmallInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I4 or VT_I8, depending on the
	bitness of the host machine)."

	^VARIANT fromSmallInteger: self! !
!SmallInteger categoriesFor: #asVariant!converting!public! !

!SmalltalkLocale methodsFor!

variantBool: aBoolean
	^aBoolean class name! !
!SmalltalkLocale categoriesFor: #variantBool:!constants!public! !

!String methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^VARIANT fromString: self! !
!String categoriesFor: #asVariant!converting!public! !

!String class methodsFor!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^LPSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_LPSTR! !
!String class categoriesFor: #pointerType!constants!private! !
!String class categoriesFor: #typeName!constants!private! !
!String class categoriesFor: #vt!constants!public! !

!SWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I2! !
!SWORD class categoriesFor: #typeName!constants!private! !
!SWORD class categoriesFor: #vt!constants!public! !

!SYSTEMTIME methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	| vtime |
	vtime := DATE new.
	OLEAutLibrary default systemTimeToVariantTime: self pvtime: vtime.
	^vtime!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_DATE)"

	^VARIANT fromDATE: self asFloat! !
!SYSTEMTIME categoriesFor: #asFloat!converting!public! !
!SYSTEMTIME categoriesFor: #asVariant!converting!public! !

!SYSTEMTIME class methodsFor!

fromDATE: aFloat 
	| systime |
	systime := self new.
	OLEAutLibrary default variantTimeToSystemTime: aFloat lpSystemTime: systime.
	^systime! !
!SYSTEMTIME class categoriesFor: #fromDATE:!public! !

!UINT_PTR class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uintptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [AXAutomationConstants.VT_UI8] ifFalse: [AXAutomationConstants.VT_UI4]! !
!UINT_PTR class categoriesFor: #typeName!constants!private! !
!UINT_PTR class categoriesFor: #vt!constants!public! !

!ULARGE_INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#qword! !
!ULARGE_INTEGER class categoriesFor: #typeName!constants!private! !

!UndefinedObject methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_EMPTY).
	Implementation Note: VT_EMPTY is chosen for compatibility with VB which
	uses VT_EMPTY for null object references, even though VT_NULL might
	appear more appropriate at first glance."

	^VARIANT new! !
!UndefinedObject categoriesFor: #asVariant!converting!public! !

!UndefinedObject class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver."

	^#nil!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_EMPTY! !
!UndefinedObject class categoriesFor: #typeName!constants!private! !
!UndefinedObject class categoriesFor: #vt!constants!public! !

!Utf16String class methodsFor!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^LPWSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpwstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_LPWSTR! !
!Utf16String class categoriesFor: #pointerType!constants!private! !
!Utf16String class categoriesFor: #typeName!constants!private! !
!Utf16String class categoriesFor: #vt!constants!public! !

!VOID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_VOID! !
!VOID class categoriesFor: #typeName!constants!private! !
!VOID class categoriesFor: #vt!constants!public! !

!WindowsLocale methodsFor!

boolFormat
	"Answer an <Array> of two <String>s, being the representations for false and true in this Locale."

	^{self variantBool: false. self variantBool: true}!

getVariantBoolString: anInteger
	| bstr str |
	bstr := BSTR new.
	OLEAutLibrary default
		varBstrFromBool: anInteger
		lcid: self lcid
		dwFlags: AXAutomationConstants.VARIANT_LOCALBOOL
		pbstrOut: bstr.
	str := bstr asUtf8String.
	bstr free.
	^str!

variantBool: aBoolean
	^info at: aBoolean class name
		ifAbsentPut: 
			[self getVariantBoolString: (aBoolean
						ifTrue: [AXAutomationConstants.VARIANT_TRUE]
						ifFalse: [AXAutomationConstants.VARIANT_FALSE])]! !
!WindowsLocale categoriesFor: #boolFormat!constants!public! !
!WindowsLocale categoriesFor: #getVariantBoolString:!constants!public! !
!WindowsLocale categoriesFor: #variantBool:!constants!public! !

!WORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#word!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI2! !
!WORD class categoriesFor: #typeName!constants!private! !
!WORD class categoriesFor: #vt!constants!public! !

"End of package definition"!

